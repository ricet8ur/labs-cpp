# Реквизиты
Жолобов Даниил Валерьевич
3 курс
z33434
2024

# ЛР #5: [C++ & UNIX]: C++ OOP / PARALLEL

# Цель

Познакомить студента с принципами объектно-ориентированного программирования на примере создания сложной синтаксической структуры. Придумать синтаксис своего персонального мини-языка параллельного программирования, а также реализовать его разбор и вычисление.

# Задача

1. [С++ PARALLEL LANG] Создать параллельный язык программирования
<pre>
Требуется создать язык программирования, в котором будет доступна установка следующих команд:
- Установка счетного цикла
- Вывод в консоль
- Вывод в файл в режиме добавления
- Арифметические операции +, -, *, /

Счетный цикл должен поддерживать дальнейшую установку всех остальных поддерживаемых команд.

Для реализации задачи использовать технологию объектно-ориентированного программирования в части реализации поддерживаемых команд языка
</pre>

В программе должны быть отражены следующие шаги:
1. Текстовый ввод команд. Каждая новая строка – это новый набор команд.
2. Ожидание команды на окончание ввода
3. Параллельное исполнение введенных строк (наборов команд). Наборы команд должны исполняться параллельно. В консоли фиксировать время запуска / завершения каждого потока. При выводе информации о времени указывать принадлежность потока к строке (набору команд)

2. [LOG] Результат всех вышеперечисленных шагов сохранить в репозиторий (+ отчет по данной ЛР в папку doc)

<pre>
Фиксацию ревизий производить строго через ветку dev. С помощью скриптов накатить ревизии на stg и на prd. Скрипты разместить в корне репозитория. Также создать скрипты по возврату к виду текущей ревизии (даже если в папке имеются несохраненные изменения + новые файлы).
</pre>

# Решение

1. [С++ PARALLEL LANG] Создать параллельный язык программирования
<pre>
Требуется создать язык программирования, в котором будет доступна установка следующих команд:
- Установка счетного цикла
- Вывод в консоль
- Вывод в файл в режиме добавления
- Арифметические операции +, -, *, /

Счетный цикл должен поддерживать дальнейшую установку всех остальных поддерживаемых команд.

Для реализации задачи использовать технологию объектно-ориентированного программирования в части реализации поддерживаемых команд языка
</pre>

В программе должны быть отражены следующие шаги:
1.1. Текстовый ввод команд. Каждая новая строка – это новый набор команд.

Поскольку в каждую строку можно уместить несколько команд, потребуется использовать разделитель команд. Пусть им будет ';'. Поэтому будет разумно выбрать инструкции, похожие на имеющиеся в C++, но упростить их. Язык будет похож на cpp и параллельным, так что можно его назвать "ppp" - parallel cpp.

1.2. Ожидание команды на окончание ввода

По аналогии с инструкциями времени компиляции можно обозвать эту команду "#endppp"

1.3. Параллельное исполнение введенных строк (наборов команд). Наборы команд должны исполняться параллельно. В консоли фиксировать время запуска / завершения каждого потока. При выводе информации о времени указывать принадлежность потока к строке (набору команд)

<pre>
Распараллеливать ход выполнения может иметь смысл в некоторых циклах и некоторых последовательных наборах команд. Чтобы понять, в каких случаях следует выполнять параллельные вычисления, можно построить граф изменения переменных.

Для начала рассмотрим простой случай - только последовательность команд, без циклов. Тогда достаточно проанализировать следующие инструкции:
- variable definition [T]
- variable redefinition [T,T]
- operators[T,T] -> T
- printf to std_out
- fprintf to to file 

variable definition принимает название переменной и значение. После этой команды в области видимости появляется ещё одна переменная. Это одна из крайних точек графа:
*
|
variable redefinition принимает название переменной и значение. Для простоты приведение типов отсутствует. Это узел графа:
|/
*
|
operator принимает два названия переменных и возвращает значение. Это узел графа.


Попробуем реализовать
- входные переменные - вычисленные expression[T]->T
- присваивание как expression[T]->T
- бинарные операции как expression[T,T]->T

a <- 0;
q <- 0.;
[w<~1:3:5]{w <-a+q;"f";print('a',"beta",w); file_print<"file.txt">('b',"test",a);}
print(w);

Рассмотрим поведение арифметических выражений для построения графа выполнения операций с переменными.
Есть операция создания новой переменной из непараллельной переменной.
add_variable
Есть операция перемещения, которая должна вести себя как операция грубокого параллельного копирования.
auto b = add_variable;
auto a = b;
Есть операция перезаписи существующей параллельной переменной, которая должна выполнять последовательное присвоение вместо параллельного.
auto b = add_variable;
b = b;
Есть операция создания временного параллельного выражения с аргументами-параллельными переменными, которое может перейти в разряд невременного в случае записи в переменную.
auto b = add_variable;
auto с = (add_variable+b)+add_variable;
// первая скобка - временное параллельное выражение, характеризующееся тем, что у него только одно следующее выражение. После вычисления временного выражения и использования его результата оно удаляется.
// Второе выражение - временное параллельное выражение, переходящее в разряд переменных и не удаляющееся после использования результата.
</pre>

1. [LOG] Результат всех вышеперечисленных шагов сохранить в репозиторий (+ отчет по данной ЛР в папку doc)

<pre>
Фиксацию ревизий производить строго через ветку dev. С помощью скриптов накатить ревизии на stg и на prd. Скрипты разместить в корне репозитория. Также создать скрипты по возврату к виду текущей ревизии (даже если в папке имеются несохраненные изменения + новые файлы).
</pre>
